// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float4x4 CamToWorld;
float4x4 CamInverseProjection;

//enum ShapeType
//{
//    Circle = 0,
//    Cube = 1,
//    Cylinder = 2
//};

struct Shape
{
    uint shapeType;
    float3 pos;
    float3 rot;
    float3 scale;
    float4 color;
    float3 metadata;
    uint parentIndex;
};

struct BlendContainer
{
    uint blendFunc;
    uint parentBlendFunc;
    uint numChilds;
    uint numShapes;
    uint parentIndex;
};

StructuredBuffer<Shape> Shapes;
uint NumShapes;

StructuredBuffer<BlendContainer> BlendContainers;
uint NumBlendContainers;

#define MAX_STEPS 100
#define MIN_HIT_DIST 0.001f
#define MAX_TRACE_DIST 100

float GetDistFromCube(float3 pos, float3 size)
{
    float3 o = abs(pos) - size;
    float ud = length(max(o, 0));
    float n = max(max(min(o.x, 0), min(o.y, 0)), min(o.z, 0));
    return ud + n;
}

float GetDistFromSphere(float3 pos, float radius)
{
    return length(pos) - radius;
}

float GetDistFromCylinderY(float3 pos, float2 h)
{
    float2 d = abs(float2(length((pos).xz), pos.y)) - h;
    return length(max(d, 0)) + max(min(d.x, 0), min(d.y, 0));
}

float GetDistFromCylinderX(float3 pos, float2 h)
{
    float2 d = abs(float2(length((pos).yz), pos.x)) - h;
    return length(max(d, 0)) + max(min(d.x, 0), min(d.y, 0));
}

float GetDistFromCylinderZ(float3 pos, float2 h)
{
    float2 d = abs(float2(length((pos).xy), pos.z)) - h;
    return length(max(d, 0)) + max(min(d.x, 0), min(d.y, 0));
}

float intersectSDF(float distA, float distB) {
    return max(distA, distB);
}

float unionSDF(float distA, float distB) {
    return min(distA, distB);
}

float differenceSDF(float distA, float distB) {
    return max(distA, -distB);
}

float GetBlendDistance(uint blendType, float pDistance, float distance)
{
    if (blendType == 0) // union
        return unionSDF(pDistance, distance);
    else if (blendType == 1) // intersection
        return intersectSDF(pDistance, distance);
    else if (blendType == 2) // difference
        return differenceSDF(pDistance, distance);

    return 0;
}

float SceneSDF(float3 pos)
{
    float distances[25];
    uint firstBlend[25];
    float distance = 0;

    [unroll(25)] for (int j = 0; j < 25; j++)
    {
        firstBlend[j] = 0;
    }

    for (uint i = 0; i < NumShapes; i++)
    {
        int pIndex = NumShapes - 1 - i;
        Shape shape = Shapes[pIndex];

        float3 globalPos = pos - shape.pos;

        if (shape.shapeType == 0) // Circle
            distance = GetDistFromSphere(globalPos, shape.metadata.x);
        else if (shape.shapeType == 1) // Square
            distance = GetDistFromCube(globalPos, shape.metadata.xyz);
        else if (shape.shapeType == 2) // Cylinder
            distance = GetDistFromCylinderY(globalPos, shape.metadata.xy);

        uint blendFunc = BlendContainers[shape.parentIndex].blendFunc;

        if (firstBlend[shape.parentIndex] != 0)
        {
            distances[shape.parentIndex] = GetBlendDistance(blendFunc, distances[shape.parentIndex], distance);
        }
        else
        {
            distances[shape.parentIndex] = distance;
            firstBlend[shape.parentIndex] = 1;
        }
    }

    for (int k = 0; k < NumBlendContainers; k++)
    {
        int pIndex = NumBlendContainers - 1 - k;
        BlendContainer blendContainer = BlendContainers[pIndex];

        uint parentBlendFunc = BlendContainers[pIndex].parentBlendFunc;
        float parentDistance = distances[blendContainer.parentIndex];
        float distance = distances[pIndex];

        distances[blendContainer.parentIndex] = GetBlendDistance(parentBlendFunc, parentDistance, distance);
    }

    return distances[0];
}

float3 GetNormal(float3 pos)
{
    float2 eplison = float2(0.01, 0);
    float3 normal = SceneSDF(pos) - float3(
        SceneSDF(pos - eplison.xyy),
        SceneSDF(pos - eplison.yxy),
        SceneSDF(pos - eplison.yyx)
        );

    return normalize(normal);
}

float Raymarch(float3 ray_origin, float3 ray_direction)
{
    float dist_from_origin = 0.0f;
    float dist_to_surface;

    for (int i = 0; i < MAX_STEPS; i++)
    {
        float3 current_pos = ray_origin + dist_from_origin * ray_direction;

        dist_to_surface = SceneSDF(current_pos);

        dist_from_origin += dist_to_surface;

        if (dist_to_surface < MIN_HIT_DIST || dist_from_origin > MAX_TRACE_DIST)
            break;
    }

    return dist_from_origin;
}

[numthreads(6,6,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    // TODO: insert actual code here!

    float width, height = 0;
    Result.GetDimensions(width, height);

    // Calculate uv
    float2 uv = id.xy / float2(width, height) * 2 - 1;

    float3 ray_origin = mul(CamToWorld, float4(0.0, 0.0, 0.0, 1.0)).xyz;

    float3 ray_direction = mul(CamInverseProjection, float4(uv, 0, 1)).xyz;
    ray_direction = mul(CamToWorld, float4(ray_direction, 0)).xyz;
    ray_direction = normalize(ray_direction);

    float distance = Raymarch(ray_origin, ray_direction);

    if (distance < MAX_TRACE_DIST)
    {
        float3 normal = GetNormal(ray_origin + ray_direction * distance);
        Result[id.xy] = float4(normal.x, normal.y, normal.z, 1.0);
    }
    else
        Result[id.xy] = float4(0, 1, 1, 1.0);
}
